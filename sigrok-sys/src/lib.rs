/* automatically generated by rust-bindgen */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    clippy::redundant_static_lifetimes
)]

pub use glib_sys::{GArray, GHashTable, GSList, GString, GVariant};

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _SYS_TIME_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 1024;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\0";
pub const PRId8: &'static [u8; 2usize] = b"d\0";
pub const PRId16: &'static [u8; 2usize] = b"d\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRId64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const PRIi8: &'static [u8; 2usize] = b"i\0";
pub const PRIi16: &'static [u8; 2usize] = b"i\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIi64: &'static [u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\0";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\0";
pub const PRIo8: &'static [u8; 2usize] = b"o\0";
pub const PRIo16: &'static [u8; 2usize] = b"o\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIo64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const PRIu8: &'static [u8; 2usize] = b"u\0";
pub const PRIu16: &'static [u8; 2usize] = b"u\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIu64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const PRIx8: &'static [u8; 2usize] = b"x\0";
pub const PRIx16: &'static [u8; 2usize] = b"x\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIx64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const PRIX8: &'static [u8; 2usize] = b"X\0";
pub const PRIX16: &'static [u8; 2usize] = b"X\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRIX64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNd64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNi64: &'static [u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\0";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNu64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNo64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNx64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SR_MAX_CHANNELNAME_LEN: u32 = 32;
pub const SR_PACKAGE_VERSION_MAJOR: u32 = 0;
pub const SR_PACKAGE_VERSION_MINOR: u32 = 5;
pub const SR_PACKAGE_VERSION_MICRO: u32 = 2;
pub const SR_PACKAGE_VERSION_STRING: &'static [u8; 6usize] = b"0.5.2\0";
pub const SR_LIB_VERSION_CURRENT: u32 = 5;
pub const SR_LIB_VERSION_REVISION: u32 = 1;
pub const SR_LIB_VERSION_AGE: u32 = 1;
pub const SR_LIB_VERSION_STRING: &'static [u8; 6usize] = b"5:1:1\0";
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::std::os::raw::c_long;
pub type fd_mask = __fd_mask;
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
pub type __itimer_which_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
pub type gboolean = ::std::os::raw::c_char;
pub type gssize = ::std::os::raw::c_ulong;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_error_code {
    SR_OK = 0,
    SR_ERR = -1,
    SR_ERR_MALLOC = -2,
    SR_ERR_ARG = -3,
    SR_ERR_BUG = -4,
    SR_ERR_SAMPLERATE = -5,
    SR_ERR_NA = -6,
    SR_ERR_DEV_CLOSED = -7,
    SR_ERR_TIMEOUT = -8,
    SR_ERR_CHANNEL_GROUP = -9,
    SR_ERR_DATA = -10,
    SR_ERR_IO = -11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_loglevel {
    SR_LOG_NONE = 0,
    SR_LOG_ERR = 1,
    SR_LOG_WARN = 2,
    SR_LOG_INFO = 3,
    SR_LOG_DBG = 4,
    SR_LOG_SPEW = 5,
}
pub type sr_receive_data_callback = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        revents: ::std::os::raw::c_int,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_datatype {
    SR_T_UINT64 = 10000,
    SR_T_STRING = 10001,
    SR_T_BOOL = 10002,
    SR_T_FLOAT = 10003,
    SR_T_RATIONAL_PERIOD = 10004,
    SR_T_RATIONAL_VOLT = 10005,
    SR_T_KEYVALUE = 10006,
    SR_T_UINT64_RANGE = 10007,
    SR_T_DOUBLE_RANGE = 10008,
    SR_T_INT32 = 10009,
    SR_T_MQ = 10010,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_packettype {
    SR_DF_HEADER = 10000,
    SR_DF_END = 10001,
    SR_DF_META = 10002,
    SR_DF_TRIGGER = 10003,
    SR_DF_LOGIC = 10004,
    SR_DF_FRAME_BEGIN = 10005,
    SR_DF_FRAME_END = 10006,
    SR_DF_ANALOG = 10007,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_mq {
    SR_MQ_VOLTAGE = 10000,
    SR_MQ_CURRENT = 10001,
    SR_MQ_RESISTANCE = 10002,
    SR_MQ_CAPACITANCE = 10003,
    SR_MQ_TEMPERATURE = 10004,
    SR_MQ_FREQUENCY = 10005,
    SR_MQ_DUTY_CYCLE = 10006,
    SR_MQ_CONTINUITY = 10007,
    SR_MQ_PULSE_WIDTH = 10008,
    SR_MQ_CONDUCTANCE = 10009,
    SR_MQ_POWER = 10010,
    SR_MQ_GAIN = 10011,
    SR_MQ_SOUND_PRESSURE_LEVEL = 10012,
    SR_MQ_CARBON_MONOXIDE = 10013,
    SR_MQ_RELATIVE_HUMIDITY = 10014,
    SR_MQ_TIME = 10015,
    SR_MQ_WIND_SPEED = 10016,
    SR_MQ_PRESSURE = 10017,
    SR_MQ_PARALLEL_INDUCTANCE = 10018,
    SR_MQ_PARALLEL_CAPACITANCE = 10019,
    SR_MQ_PARALLEL_RESISTANCE = 10020,
    SR_MQ_SERIES_INDUCTANCE = 10021,
    SR_MQ_SERIES_CAPACITANCE = 10022,
    SR_MQ_SERIES_RESISTANCE = 10023,
    SR_MQ_DISSIPATION_FACTOR = 10024,
    SR_MQ_QUALITY_FACTOR = 10025,
    SR_MQ_PHASE_ANGLE = 10026,
    SR_MQ_DIFFERENCE = 10027,
    SR_MQ_COUNT = 10028,
    SR_MQ_POWER_FACTOR = 10029,
    SR_MQ_APPARENT_POWER = 10030,
    SR_MQ_MASS = 10031,
    SR_MQ_HARMONIC_RATIO = 10032,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_unit {
    SR_UNIT_VOLT = 10000,
    SR_UNIT_AMPERE = 10001,
    SR_UNIT_OHM = 10002,
    SR_UNIT_FARAD = 10003,
    SR_UNIT_KELVIN = 10004,
    SR_UNIT_CELSIUS = 10005,
    SR_UNIT_FAHRENHEIT = 10006,
    SR_UNIT_HERTZ = 10007,
    SR_UNIT_PERCENTAGE = 10008,
    SR_UNIT_BOOLEAN = 10009,
    SR_UNIT_SECOND = 10010,
    SR_UNIT_SIEMENS = 10011,
    SR_UNIT_DECIBEL_MW = 10012,
    SR_UNIT_DECIBEL_VOLT = 10013,
    SR_UNIT_UNITLESS = 10014,
    SR_UNIT_DECIBEL_SPL = 10015,
    SR_UNIT_CONCENTRATION = 10016,
    SR_UNIT_REVOLUTIONS_PER_MINUTE = 10017,
    SR_UNIT_VOLT_AMPERE = 10018,
    SR_UNIT_WATT = 10019,
    SR_UNIT_WATT_HOUR = 10020,
    SR_UNIT_METER_SECOND = 10021,
    SR_UNIT_HECTOPASCAL = 10022,
    SR_UNIT_HUMIDITY_293K = 10023,
    SR_UNIT_DEGREE = 10024,
    SR_UNIT_HENRY = 10025,
    SR_UNIT_GRAM = 10026,
    SR_UNIT_CARAT = 10027,
    SR_UNIT_OUNCE = 10028,
    SR_UNIT_TROY_OUNCE = 10029,
    SR_UNIT_POUND = 10030,
    SR_UNIT_PENNYWEIGHT = 10031,
    SR_UNIT_GRAIN = 10032,
    SR_UNIT_TAEL = 10033,
    SR_UNIT_MOMME = 10034,
    SR_UNIT_TOLA = 10035,
    SR_UNIT_PIECE = 10036,
}
impl sr_mqflag {
    pub const SR_MQFLAG_AC: sr_mqflag = sr_mqflag(1);
}
impl sr_mqflag {
    pub const SR_MQFLAG_DC: sr_mqflag = sr_mqflag(2);
}
impl sr_mqflag {
    pub const SR_MQFLAG_RMS: sr_mqflag = sr_mqflag(4);
}
impl sr_mqflag {
    pub const SR_MQFLAG_DIODE: sr_mqflag = sr_mqflag(8);
}
impl sr_mqflag {
    pub const SR_MQFLAG_HOLD: sr_mqflag = sr_mqflag(16);
}
impl sr_mqflag {
    pub const SR_MQFLAG_MAX: sr_mqflag = sr_mqflag(32);
}
impl sr_mqflag {
    pub const SR_MQFLAG_MIN: sr_mqflag = sr_mqflag(64);
}
impl sr_mqflag {
    pub const SR_MQFLAG_AUTORANGE: sr_mqflag = sr_mqflag(128);
}
impl sr_mqflag {
    pub const SR_MQFLAG_RELATIVE: sr_mqflag = sr_mqflag(256);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_FREQ_WEIGHT_A: sr_mqflag = sr_mqflag(512);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_FREQ_WEIGHT_C: sr_mqflag = sr_mqflag(1024);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_FREQ_WEIGHT_Z: sr_mqflag = sr_mqflag(2048);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_FREQ_WEIGHT_FLAT: sr_mqflag = sr_mqflag(4096);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_TIME_WEIGHT_S: sr_mqflag = sr_mqflag(8192);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_TIME_WEIGHT_F: sr_mqflag = sr_mqflag(16384);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_LAT: sr_mqflag = sr_mqflag(32768);
}
impl sr_mqflag {
    pub const SR_MQFLAG_SPL_PCT_OVER_ALARM: sr_mqflag = sr_mqflag(65536);
}
impl sr_mqflag {
    pub const SR_MQFLAG_DURATION: sr_mqflag = sr_mqflag(131072);
}
impl sr_mqflag {
    pub const SR_MQFLAG_AVG: sr_mqflag = sr_mqflag(262144);
}
impl sr_mqflag {
    pub const SR_MQFLAG_REFERENCE: sr_mqflag = sr_mqflag(524288);
}
impl sr_mqflag {
    pub const SR_MQFLAG_UNSTABLE: sr_mqflag = sr_mqflag(1048576);
}
impl sr_mqflag {
    pub const SR_MQFLAG_FOUR_WIRE: sr_mqflag = sr_mqflag(2097152);
}
impl ::std::ops::BitOr<sr_mqflag> for sr_mqflag {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        sr_mqflag(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for sr_mqflag {
    #[inline]
    fn bitor_assign(&mut self, rhs: sr_mqflag) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<sr_mqflag> for sr_mqflag {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        sr_mqflag(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for sr_mqflag {
    #[inline]
    fn bitand_assign(&mut self, rhs: sr_mqflag) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub struct sr_mqflag(pub u32);
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_trigger_matches {
    SR_TRIGGER_ZERO = 1,
    SR_TRIGGER_ONE = 2,
    SR_TRIGGER_RISING = 3,
    SR_TRIGGER_FALLING = 4,
    SR_TRIGGER_EDGE = 5,
    SR_TRIGGER_OVER = 6,
    SR_TRIGGER_UNDER = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_trigger {
    pub name: *mut ::std::os::raw::c_char,
    pub stages: *mut GSList,
}
#[test]
fn bindgen_test_layout_sr_trigger() {
    assert_eq!(
        ::std::mem::size_of::<sr_trigger>(),
        16usize,
        concat!("Size of: ", stringify!(sr_trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_trigger>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_trigger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger>())).stages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger),
            "::",
            stringify!(stages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_trigger_stage {
    pub stage: ::std::os::raw::c_int,
    pub matches: *mut GSList,
}
#[test]
fn bindgen_test_layout_sr_trigger_stage() {
    assert_eq!(
        ::std::mem::size_of::<sr_trigger_stage>(),
        16usize,
        concat!("Size of: ", stringify!(sr_trigger_stage))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_trigger_stage>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_trigger_stage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger_stage>())).stage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger_stage),
            "::",
            stringify!(stage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger_stage>())).matches as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger_stage),
            "::",
            stringify!(matches)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_trigger_match {
    pub channel: *mut sr_channel,
    pub match_: ::std::os::raw::c_int,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sr_trigger_match() {
    assert_eq!(
        ::std::mem::size_of::<sr_trigger_match>(),
        16usize,
        concat!("Size of: ", stringify!(sr_trigger_match))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_trigger_match>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_trigger_match))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger_match>())).channel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger_match),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger_match>())).match_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger_match),
            "::",
            stringify!(match_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_trigger_match>())).value as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_trigger_match),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_rational {
    pub p: i64,
    pub q: u64,
}
#[test]
fn bindgen_test_layout_sr_rational() {
    assert_eq!(
        ::std::mem::size_of::<sr_rational>(),
        16usize,
        concat!("Size of: ", stringify!(sr_rational))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_rational>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_rational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_rational>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_rational),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_rational>())).q as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_rational),
            "::",
            stringify!(q)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_datafeed_packet {
    pub type_: u16,
    pub payload: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sr_datafeed_packet() {
    assert_eq!(
        ::std::mem::size_of::<sr_datafeed_packet>(),
        16usize,
        concat!("Size of: ", stringify!(sr_datafeed_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_datafeed_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_datafeed_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_packet>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_packet),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_packet>())).payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_packet),
            "::",
            stringify!(payload)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_datafeed_header {
    pub feed_version: ::std::os::raw::c_int,
    pub starttime: timeval,
}
#[test]
fn bindgen_test_layout_sr_datafeed_header() {
    assert_eq!(
        ::std::mem::size_of::<sr_datafeed_header>(),
        24usize,
        concat!("Size of: ", stringify!(sr_datafeed_header))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_datafeed_header>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_datafeed_header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_header>())).feed_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_header),
            "::",
            stringify!(feed_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_header>())).starttime as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_header),
            "::",
            stringify!(starttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_datafeed_meta {
    pub config: *mut GSList,
}
#[test]
fn bindgen_test_layout_sr_datafeed_meta() {
    assert_eq!(
        ::std::mem::size_of::<sr_datafeed_meta>(),
        8usize,
        concat!("Size of: ", stringify!(sr_datafeed_meta))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_datafeed_meta>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_datafeed_meta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_meta>())).config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_meta),
            "::",
            stringify!(config)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_datafeed_logic {
    pub length: u64,
    pub unitsize: u16,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sr_datafeed_logic() {
    assert_eq!(
        ::std::mem::size_of::<sr_datafeed_logic>(),
        24usize,
        concat!("Size of: ", stringify!(sr_datafeed_logic))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_datafeed_logic>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_datafeed_logic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_logic>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_logic),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_logic>())).unitsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_logic),
            "::",
            stringify!(unitsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_logic>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_logic),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_datafeed_analog {
    pub data: *mut ::std::os::raw::c_void,
    pub num_samples: u32,
    pub encoding: *mut sr_analog_encoding,
    pub meaning: *mut sr_analog_meaning,
    pub spec: *mut sr_analog_spec,
}
#[test]
fn bindgen_test_layout_sr_datafeed_analog() {
    assert_eq!(
        ::std::mem::size_of::<sr_datafeed_analog>(),
        40usize,
        concat!("Size of: ", stringify!(sr_datafeed_analog))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_datafeed_analog>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_datafeed_analog))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_analog>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_analog),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_analog>())).num_samples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_analog),
            "::",
            stringify!(num_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_analog>())).encoding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_analog),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_analog>())).meaning as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_analog),
            "::",
            stringify!(meaning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_datafeed_analog>())).spec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_datafeed_analog),
            "::",
            stringify!(spec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_analog_encoding {
    pub unitsize: u8,
    pub is_signed: gboolean,
    pub is_float: gboolean,
    pub is_bigendian: gboolean,
    pub digits: i8,
    pub is_digits_decimal: gboolean,
    pub scale: sr_rational,
    pub offset: sr_rational,
}
#[test]
fn bindgen_test_layout_sr_analog_encoding() {
    assert_eq!(
        ::std::mem::size_of::<sr_analog_encoding>(),
        40usize,
        concat!("Size of: ", stringify!(sr_analog_encoding))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_analog_encoding>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_analog_encoding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).unitsize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(unitsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).is_signed as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(is_signed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).is_float as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(is_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).is_bigendian as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(is_bigendian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).digits as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(digits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sr_analog_encoding>())).is_digits_decimal as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(is_digits_decimal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).scale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_encoding>())).offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_encoding),
            "::",
            stringify!(offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_analog_meaning {
    pub mq: sr_mq,
    pub unit: sr_unit,
    pub mqflags: sr_mqflag,
    pub channels: *mut GSList,
}
#[test]
fn bindgen_test_layout_sr_analog_meaning() {
    assert_eq!(
        ::std::mem::size_of::<sr_analog_meaning>(),
        24usize,
        concat!("Size of: ", stringify!(sr_analog_meaning))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_analog_meaning>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_analog_meaning))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_meaning>())).mq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_meaning),
            "::",
            stringify!(mq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_meaning>())).unit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_meaning),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_meaning>())).mqflags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_meaning),
            "::",
            stringify!(mqflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_meaning>())).channels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_meaning),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_analog_spec {
    pub spec_digits: i8,
}
#[test]
fn bindgen_test_layout_sr_analog_spec() {
    assert_eq!(
        ::std::mem::size_of::<sr_analog_spec>(),
        1usize,
        concat!("Size of: ", stringify!(sr_analog_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_analog_spec>(),
        1usize,
        concat!("Alignment of ", stringify!(sr_analog_spec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_analog_spec>())).spec_digits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_analog_spec),
            "::",
            stringify!(spec_digits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_option {
    pub id: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub def: *mut GVariant,
    pub values: *mut GSList,
}
#[test]
fn bindgen_test_layout_sr_option() {
    assert_eq!(
        ::std::mem::size_of::<sr_option>(),
        40usize,
        concat!("Size of: ", stringify!(sr_option))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_option>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_option))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_option>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_option),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_option>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_option>())).desc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_option),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_option>())).def as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_option),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_option>())).values as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_option),
            "::",
            stringify!(values)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_resource_type {
    SR_RESOURCE_FIRMWARE = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_resource {
    pub size: u64,
    pub handle: *mut ::std::os::raw::c_void,
    pub type_: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sr_resource() {
    assert_eq!(
        ::std::mem::size_of::<sr_resource>(),
        24usize,
        concat!("Size of: ", stringify!(sr_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_resource>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_resource),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_resource>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_resource),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_resource>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_resource),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_output_flag {
    SR_OUTPUT_INTERNAL_IO_HANDLING = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_input {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_input_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_output_module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_transform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_transform_module {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_channeltype {
    SR_CHANNEL_LOGIC = 10000,
    SR_CHANNEL_ANALOG = 10001,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_channel {
    pub sdi: *mut sr_dev_inst,
    pub index: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub enabled: gboolean,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sr_channel() {
    assert_eq!(
        ::std::mem::size_of::<sr_channel>(),
        40usize,
        concat!("Size of: ", stringify!(sr_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel>())).sdi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel),
            "::",
            stringify!(sdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel>())).enabled as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_channel_group {
    pub name: *mut ::std::os::raw::c_char,
    pub channels: *mut GSList,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sr_channel_group() {
    assert_eq!(
        ::std::mem::size_of::<sr_channel_group>(),
        24usize,
        concat!("Size of: ", stringify!(sr_channel_group))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_channel_group>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_channel_group))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel_group>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel_group),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel_group>())).channels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel_group),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_channel_group>())).priv_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_channel_group),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_config {
    pub key: u32,
    pub data: *mut GVariant,
}
#[test]
fn bindgen_test_layout_sr_config() {
    assert_eq!(
        ::std::mem::size_of::<sr_config>(),
        16usize,
        concat!("Size of: ", stringify!(sr_config))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_config>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_config))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_config>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_config),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_config>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_config),
            "::",
            stringify!(data)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_keytype {
    SR_KEY_CONFIG = 0,
    SR_KEY_MQ = 1,
    SR_KEY_MQFLAGS = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_key_info {
    pub key: u32,
    pub datatype: ::std::os::raw::c_int,
    pub id: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sr_key_info() {
    assert_eq!(
        ::std::mem::size_of::<sr_key_info>(),
        32usize,
        concat!("Size of: ", stringify!(sr_key_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_key_info>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_key_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_key_info>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_key_info),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_key_info>())).datatype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_key_info),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_key_info>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_key_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_key_info>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_key_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_key_info>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_key_info),
            "::",
            stringify!(description)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_configcap {
    SR_CONF_GET = 2147483648,
    SR_CONF_SET = 1073741824,
    SR_CONF_LIST = 536870912,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_configkey {
    SR_CONF_LOGIC_ANALYZER = 10000,
    SR_CONF_OSCILLOSCOPE = 10001,
    SR_CONF_MULTIMETER = 10002,
    SR_CONF_DEMO_DEV = 10003,
    SR_CONF_SOUNDLEVELMETER = 10004,
    SR_CONF_THERMOMETER = 10005,
    SR_CONF_HYGROMETER = 10006,
    SR_CONF_ENERGYMETER = 10007,
    SR_CONF_DEMODULATOR = 10008,
    SR_CONF_POWER_SUPPLY = 10009,
    SR_CONF_LCRMETER = 10010,
    SR_CONF_ELECTRONIC_LOAD = 10011,
    SR_CONF_SCALE = 10012,
    SR_CONF_SIGNAL_GENERATOR = 10013,
    SR_CONF_POWERMETER = 10014,
    SR_CONF_CONN = 20000,
    SR_CONF_SERIALCOMM = 20001,
    SR_CONF_MODBUSADDR = 20002,
    SR_CONF_SAMPLERATE = 30000,
    SR_CONF_CAPTURE_RATIO = 30001,
    SR_CONF_PATTERN_MODE = 30002,
    SR_CONF_RLE = 30003,
    SR_CONF_TRIGGER_SLOPE = 30004,
    SR_CONF_AVERAGING = 30005,
    SR_CONF_AVG_SAMPLES = 30006,
    SR_CONF_TRIGGER_SOURCE = 30007,
    SR_CONF_HORIZ_TRIGGERPOS = 30008,
    SR_CONF_BUFFERSIZE = 30009,
    SR_CONF_TIMEBASE = 30010,
    SR_CONF_FILTER = 30011,
    SR_CONF_VDIV = 30012,
    SR_CONF_COUPLING = 30013,
    SR_CONF_TRIGGER_MATCH = 30014,
    SR_CONF_SAMPLE_INTERVAL = 30015,
    SR_CONF_NUM_HDIV = 30016,
    SR_CONF_NUM_VDIV = 30017,
    SR_CONF_SPL_WEIGHT_FREQ = 30018,
    SR_CONF_SPL_WEIGHT_TIME = 30019,
    SR_CONF_SPL_MEASUREMENT_RANGE = 30020,
    SR_CONF_HOLD_MAX = 30021,
    SR_CONF_HOLD_MIN = 30022,
    SR_CONF_VOLTAGE_THRESHOLD = 30023,
    SR_CONF_EXTERNAL_CLOCK = 30024,
    SR_CONF_SWAP = 30025,
    SR_CONF_CENTER_FREQUENCY = 30026,
    SR_CONF_NUM_LOGIC_CHANNELS = 30027,
    SR_CONF_NUM_ANALOG_CHANNELS = 30028,
    SR_CONF_VOLTAGE = 30029,
    SR_CONF_VOLTAGE_TARGET = 30030,
    SR_CONF_CURRENT = 30031,
    SR_CONF_CURRENT_LIMIT = 30032,
    SR_CONF_ENABLED = 30033,
    SR_CONF_CHANNEL_CONFIG = 30034,
    SR_CONF_OVER_VOLTAGE_PROTECTION_ENABLED = 30035,
    SR_CONF_OVER_VOLTAGE_PROTECTION_ACTIVE = 30036,
    SR_CONF_OVER_VOLTAGE_PROTECTION_THRESHOLD = 30037,
    SR_CONF_OVER_CURRENT_PROTECTION_ENABLED = 30038,
    SR_CONF_OVER_CURRENT_PROTECTION_ACTIVE = 30039,
    SR_CONF_OVER_CURRENT_PROTECTION_THRESHOLD = 30040,
    SR_CONF_CLOCK_EDGE = 30041,
    SR_CONF_AMPLITUDE = 30042,
    SR_CONF_REGULATION = 30043,
    SR_CONF_OVER_TEMPERATURE_PROTECTION = 30044,
    SR_CONF_OUTPUT_FREQUENCY = 30045,
    SR_CONF_OUTPUT_FREQUENCY_TARGET = 30046,
    SR_CONF_MEASURED_QUANTITY = 30047,
    SR_CONF_EQUIV_CIRCUIT_MODEL = 30048,
    SR_CONF_OVER_TEMPERATURE_PROTECTION_ACTIVE = 30049,
    SR_CONF_UNDER_VOLTAGE_CONDITION = 30050,
    SR_CONF_UNDER_VOLTAGE_CONDITION_ACTIVE = 30051,
    SR_CONF_TRIGGER_LEVEL = 30052,
    SR_CONF_UNDER_VOLTAGE_CONDITION_THRESHOLD = 30053,
    SR_CONF_EXTERNAL_CLOCK_SOURCE = 30054,
    SR_CONF_OFFSET = 30055,
    SR_CONF_TRIGGER_PATTERN = 30056,
    SR_CONF_HIGH_RESOLUTION = 30057,
    SR_CONF_PEAK_DETECTION = 30058,
    SR_CONF_LOGIC_THRESHOLD = 30059,
    SR_CONF_LOGIC_THRESHOLD_CUSTOM = 30060,
    SR_CONF_RANGE = 30061,
    SR_CONF_DIGITS = 30062,
    SR_CONF_SESSIONFILE = 40000,
    SR_CONF_CAPTUREFILE = 40001,
    SR_CONF_CAPTURE_UNITSIZE = 40002,
    SR_CONF_POWER_OFF = 40003,
    SR_CONF_DATA_SOURCE = 40004,
    SR_CONF_PROBE_FACTOR = 40005,
    SR_CONF_ADC_POWERLINE_CYCLES = 40006,
    SR_CONF_LIMIT_MSEC = 50000,
    SR_CONF_LIMIT_SAMPLES = 50001,
    SR_CONF_LIMIT_FRAMES = 50002,
    SR_CONF_CONTINUOUS = 50003,
    SR_CONF_DATALOG = 50004,
    SR_CONF_DEVICE_MODE = 50005,
    SR_CONF_TEST_MODE = 50006,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_dev_inst {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_dev_inst_type {
    SR_INST_USB = 10000,
    SR_INST_SERIAL = 10001,
    SR_INST_SCPI = 10002,
    SR_INST_USER = 10003,
    SR_INST_MODBUS = 10004,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sr_dev_inst_status {
    SR_ST_NOT_FOUND = 10000,
    SR_ST_INITIALIZING = 10001,
    SR_ST_INACTIVE = 10002,
    SR_ST_ACTIVE = 10003,
    SR_ST_STOPPING = 10004,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_dev_driver {
    pub name: *const ::std::os::raw::c_char,
    pub longname: *const ::std::os::raw::c_char,
    pub api_version: ::std::os::raw::c_int,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            driver: *mut sr_dev_driver,
            sr_ctx: *mut sr_context,
        ) -> ::std::os::raw::c_int,
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(driver: *const sr_dev_driver) -> ::std::os::raw::c_int,
    >,
    pub scan: ::std::option::Option<
        unsafe extern "C" fn(driver: *mut sr_dev_driver, options: *mut GSList) -> *mut GSList,
    >,
    pub dev_list:
        ::std::option::Option<unsafe extern "C" fn(driver: *const sr_dev_driver) -> *mut GSList>,
    pub dev_clear: ::std::option::Option<
        unsafe extern "C" fn(driver: *const sr_dev_driver) -> ::std::os::raw::c_int,
    >,
    pub config_get: ::std::option::Option<
        unsafe extern "C" fn(
            key: u32,
            data: *mut *mut GVariant,
            sdi: *const sr_dev_inst,
            cg: *const sr_channel_group,
        ) -> ::std::os::raw::c_int,
    >,
    pub config_set: ::std::option::Option<
        unsafe extern "C" fn(
            key: u32,
            data: *mut GVariant,
            sdi: *const sr_dev_inst,
            cg: *const sr_channel_group,
        ) -> ::std::os::raw::c_int,
    >,
    pub config_channel_set: ::std::option::Option<
        unsafe extern "C" fn(
            sdi: *const sr_dev_inst,
            ch: *mut sr_channel,
            changes: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
    >,
    pub config_commit: ::std::option::Option<
        unsafe extern "C" fn(sdi: *const sr_dev_inst) -> ::std::os::raw::c_int,
    >,
    pub config_list: ::std::option::Option<
        unsafe extern "C" fn(
            key: u32,
            data: *mut *mut GVariant,
            sdi: *const sr_dev_inst,
            cg: *const sr_channel_group,
        ) -> ::std::os::raw::c_int,
    >,
    pub dev_open:
        ::std::option::Option<unsafe extern "C" fn(sdi: *mut sr_dev_inst) -> ::std::os::raw::c_int>,
    pub dev_close:
        ::std::option::Option<unsafe extern "C" fn(sdi: *mut sr_dev_inst) -> ::std::os::raw::c_int>,
    pub dev_acquisition_start: ::std::option::Option<
        unsafe extern "C" fn(sdi: *const sr_dev_inst) -> ::std::os::raw::c_int,
    >,
    pub dev_acquisition_stop:
        ::std::option::Option<unsafe extern "C" fn(sdi: *mut sr_dev_inst) -> ::std::os::raw::c_int>,
    pub context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sr_dev_driver() {
    assert_eq!(
        ::std::mem::size_of::<sr_dev_driver>(),
        144usize,
        concat!("Size of: ", stringify!(sr_dev_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_dev_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_dev_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).longname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(longname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).api_version as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(api_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).cleanup as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).scan as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).dev_list as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(dev_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).dev_clear as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(dev_clear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).config_get as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(config_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).config_set as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(config_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sr_dev_driver>())).config_channel_set as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(config_channel_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).config_commit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(config_commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).config_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(config_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).dev_open as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(dev_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).dev_close as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(dev_close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sr_dev_driver>())).dev_acquisition_start as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(dev_acquisition_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sr_dev_driver>())).dev_acquisition_stop as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(dev_acquisition_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_dev_driver>())).context as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_dev_driver),
            "::",
            stringify!(context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sr_serial_port {
    pub name: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_sr_serial_port() {
    assert_eq!(
        ::std::mem::size_of::<sr_serial_port>(),
        16usize,
        concat!("Size of: ", stringify!(sr_serial_port))
    );
    assert_eq!(
        ::std::mem::align_of::<sr_serial_port>(),
        8usize,
        concat!("Alignment of ", stringify!(sr_serial_port))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_serial_port>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_serial_port),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sr_serial_port>())).description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sr_serial_port),
            "::",
            stringify!(description)
        )
    );
}
extern "C" {
    pub fn sr_analog_to_float(
        analog: *const sr_datafeed_analog,
        buf: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_analog_si_prefix(
        value: *mut f32,
        digits: *mut ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_analog_si_prefix_friendly(unit: sr_unit) -> gboolean;
}
extern "C" {
    pub fn sr_analog_unit_to_string(
        analog: *const sr_datafeed_analog,
        result: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_rational_set(r: *mut sr_rational, p: i64, q: u64);
}
extern "C" {
    pub fn sr_rational_eq(a: *const sr_rational, b: *const sr_rational) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_rational_mult(
        res: *mut sr_rational,
        a: *const sr_rational,
        b: *const sr_rational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_rational_div(
        res: *mut sr_rational,
        num: *const sr_rational,
        div: *const sr_rational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_init(ctx: *mut *mut sr_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_exit(ctx: *mut sr_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_buildinfo_libs_get() -> *mut GSList;
}
extern "C" {
    pub fn sr_buildinfo_host_get() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_buildinfo_scpi_backends_get() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_a2l_threshold(
        analog: *const sr_datafeed_analog,
        threshold: f32,
        output: *mut u8,
        count: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_a2l_schmitt_trigger(
        analog: *const sr_datafeed_analog,
        lo_thr: f32,
        hi_thr: f32,
        state: *mut u8,
        output: *mut u8,
        count: u64,
    ) -> ::std::os::raw::c_int;
}
pub type sr_log_callback = ::std::option::Option<
    unsafe extern "C" fn(
        cb_data: *mut ::std::os::raw::c_void,
        loglevel: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn sr_log_loglevel_set(loglevel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_log_loglevel_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_log_callback_set(
        cb: sr_log_callback,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_log_callback_set_default() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_log_callback_get(
        cb: *mut sr_log_callback,
        cb_data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_channel_name_set(
        channel: *mut sr_channel,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_channel_enable(
        channel: *mut sr_channel,
        state: gboolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_has_option(sdi: *const sr_dev_inst, key: ::std::os::raw::c_int) -> gboolean;
}
extern "C" {
    pub fn sr_dev_config_capabilities_list(
        sdi: *const sr_dev_inst,
        cg: *const sr_channel_group,
        key: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_options(
        driver: *const sr_dev_driver,
        sdi: *const sr_dev_inst,
        cg: *const sr_channel_group,
    ) -> *mut GArray;
}
extern "C" {
    pub fn sr_dev_list(driver: *const sr_dev_driver) -> *mut GSList;
}
extern "C" {
    pub fn sr_dev_clear(driver: *const sr_dev_driver) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_open(sdi: *mut sr_dev_inst) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_close(sdi: *mut sr_dev_inst) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_dev_inst_driver_get(sdi: *const sr_dev_inst) -> *mut sr_dev_driver;
}
extern "C" {
    pub fn sr_dev_inst_vendor_get(sdi: *const sr_dev_inst) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_dev_inst_model_get(sdi: *const sr_dev_inst) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_dev_inst_version_get(sdi: *const sr_dev_inst) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_dev_inst_sernum_get(sdi: *const sr_dev_inst) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_dev_inst_connid_get(sdi: *const sr_dev_inst) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_dev_inst_channels_get(sdi: *const sr_dev_inst) -> *mut GSList;
}
extern "C" {
    pub fn sr_dev_inst_channel_groups_get(sdi: *const sr_dev_inst) -> *mut GSList;
}
extern "C" {
    pub fn sr_dev_inst_user_new(
        vendor: *const ::std::os::raw::c_char,
        model: *const ::std::os::raw::c_char,
        version: *const ::std::os::raw::c_char,
    ) -> *mut sr_dev_inst;
}
extern "C" {
    pub fn sr_dev_inst_channel_add(
        sdi: *mut sr_dev_inst,
        index: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_driver_list(ctx: *const sr_context) -> *mut *mut sr_dev_driver;
}
extern "C" {
    pub fn sr_driver_init(
        ctx: *mut sr_context,
        driver: *mut sr_dev_driver,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_driver_scan_options_list(driver: *const sr_dev_driver) -> *mut GArray;
}
extern "C" {
    pub fn sr_driver_scan(driver: *mut sr_dev_driver, options: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn sr_config_get(
        driver: *const sr_dev_driver,
        sdi: *const sr_dev_inst,
        cg: *const sr_channel_group,
        key: u32,
        data: *mut *mut GVariant,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_config_set(
        sdi: *const sr_dev_inst,
        cg: *const sr_channel_group,
        key: u32,
        data: *mut GVariant,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_config_commit(sdi: *const sr_dev_inst) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_config_list(
        driver: *const sr_dev_driver,
        sdi: *const sr_dev_inst,
        cg: *const sr_channel_group,
        key: u32,
        data: *mut *mut GVariant,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_key_info_get(keytype: ::std::os::raw::c_int, key: u32) -> *const sr_key_info;
}
extern "C" {
    pub fn sr_key_info_name_get(
        keytype: ::std::os::raw::c_int,
        keyid: *const ::std::os::raw::c_char,
    ) -> *const sr_key_info;
}
pub type sr_session_stopped_callback =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type sr_datafeed_callback = ::std::option::Option<
    unsafe extern "C" fn(
        sdi: *const sr_dev_inst,
        packet: *const sr_datafeed_packet,
        cb_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn sr_session_trigger_get(session: *mut sr_session) -> *mut sr_trigger;
}
extern "C" {
    pub fn sr_session_load(
        ctx: *mut sr_context,
        filename: *const ::std::os::raw::c_char,
        session: *mut *mut sr_session,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_new(
        ctx: *mut sr_context,
        session: *mut *mut sr_session,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_destroy(session: *mut sr_session) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_dev_remove_all(session: *mut sr_session) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_dev_add(
        session: *mut sr_session,
        sdi: *mut sr_dev_inst,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_dev_remove(
        session: *mut sr_session,
        sdi: *mut sr_dev_inst,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_dev_list(
        session: *mut sr_session,
        devlist: *mut *mut GSList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_trigger_set(
        session: *mut sr_session,
        trig: *mut sr_trigger,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_datafeed_callback_remove_all(
        session: *mut sr_session,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_datafeed_callback_add(
        session: *mut sr_session,
        cb: sr_datafeed_callback,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_start(session: *mut sr_session) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_run(session: *mut sr_session) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_stop(session: *mut sr_session) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_is_running(session: *mut sr_session) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_session_stopped_callback_set(
        session: *mut sr_session,
        cb: sr_session_stopped_callback,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_packet_copy(
        packet: *const sr_datafeed_packet,
        copy: *mut *mut sr_datafeed_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_packet_free(packet: *mut sr_datafeed_packet);
}
extern "C" {
    pub fn sr_input_list() -> *mut *const sr_input_module;
}
extern "C" {
    pub fn sr_input_id_get(imod: *const sr_input_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_input_name_get(imod: *const sr_input_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_input_description_get(imod: *const sr_input_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_input_extensions_get(
        imod: *const sr_input_module,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_input_find(id: *mut ::std::os::raw::c_char) -> *const sr_input_module;
}
extern "C" {
    pub fn sr_input_options_get(imod: *const sr_input_module) -> *mut *const sr_option;
}
extern "C" {
    pub fn sr_input_options_free(options: *mut *const sr_option);
}
extern "C" {
    pub fn sr_input_new(imod: *const sr_input_module, options: *mut GHashTable) -> *mut sr_input;
}
extern "C" {
    pub fn sr_input_scan_buffer(
        buf: *mut GString,
        in_: *mut *const sr_input,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_input_scan_file(
        filename: *const ::std::os::raw::c_char,
        in_: *mut *const sr_input,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_input_module_get(in_: *const sr_input) -> *const sr_input_module;
}
extern "C" {
    pub fn sr_input_dev_inst_get(in_: *const sr_input) -> *mut sr_dev_inst;
}
extern "C" {
    pub fn sr_input_send(in_: *const sr_input, buf: *mut GString) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_input_end(in_: *const sr_input) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_input_reset(in_: *const sr_input) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_input_free(in_: *const sr_input);
}
extern "C" {
    pub fn sr_output_list() -> *mut *const sr_output_module;
}
extern "C" {
    pub fn sr_output_id_get(omod: *const sr_output_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_output_name_get(omod: *const sr_output_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_output_description_get(
        omod: *const sr_output_module,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_output_extensions_get(
        omod: *const sr_output_module,
    ) -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_output_find(id: *mut ::std::os::raw::c_char) -> *const sr_output_module;
}
extern "C" {
    pub fn sr_output_options_get(omod: *const sr_output_module) -> *mut *const sr_option;
}
extern "C" {
    pub fn sr_output_options_free(opts: *mut *const sr_option);
}
extern "C" {
    pub fn sr_output_new(
        omod: *const sr_output_module,
        params: *mut GHashTable,
        sdi: *const sr_dev_inst,
        filename: *const ::std::os::raw::c_char,
    ) -> *const sr_output;
}
extern "C" {
    pub fn sr_output_test_flag(omod: *const sr_output_module, flag: u64) -> gboolean;
}
extern "C" {
    pub fn sr_output_send(
        o: *const sr_output,
        packet: *const sr_datafeed_packet,
        out: *mut *mut GString,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_output_free(o: *const sr_output) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_transform_list() -> *mut *const sr_transform_module;
}
extern "C" {
    pub fn sr_transform_id_get(tmod: *const sr_transform_module) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_transform_name_get(tmod: *const sr_transform_module)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_transform_description_get(
        tmod: *const sr_transform_module,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_transform_find(id: *const ::std::os::raw::c_char) -> *const sr_transform_module;
}
extern "C" {
    pub fn sr_transform_options_get(tmod: *const sr_transform_module) -> *mut *const sr_option;
}
extern "C" {
    pub fn sr_transform_options_free(opts: *mut *const sr_option);
}
extern "C" {
    pub fn sr_transform_new(
        tmod: *const sr_transform_module,
        params: *mut GHashTable,
        sdi: *const sr_dev_inst,
    ) -> *const sr_transform;
}
extern "C" {
    pub fn sr_transform_free(t: *const sr_transform) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_trigger_new(name: *const ::std::os::raw::c_char) -> *mut sr_trigger;
}
extern "C" {
    pub fn sr_trigger_free(trig: *mut sr_trigger);
}
extern "C" {
    pub fn sr_trigger_stage_add(trig: *mut sr_trigger) -> *mut sr_trigger_stage;
}
extern "C" {
    pub fn sr_trigger_match_add(
        stage: *mut sr_trigger_stage,
        ch: *mut sr_channel,
        trigger_match: ::std::os::raw::c_int,
        value: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_serial_list(driver: *const sr_dev_driver) -> *mut GSList;
}
extern "C" {
    pub fn sr_serial_free(serial: *mut sr_serial_port);
}
pub type sr_resource_open_callback = ::std::option::Option<
    unsafe extern "C" fn(
        res: *mut sr_resource,
        name: *const ::std::os::raw::c_char,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type sr_resource_close_callback = ::std::option::Option<
    unsafe extern "C" fn(
        res: *mut sr_resource,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type sr_resource_read_callback = ::std::option::Option<
    unsafe extern "C" fn(
        res: *const sr_resource,
        buf: *mut ::std::os::raw::c_void,
        count: size_t,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> gssize,
>;
extern "C" {
    pub fn sr_resourcepaths_get(res_type: ::std::os::raw::c_int) -> *mut GSList;
}
extern "C" {
    pub fn sr_resource_set_hooks(
        ctx: *mut sr_context,
        open_cb: sr_resource_open_callback,
        close_cb: sr_resource_close_callback,
        read_cb: sr_resource_read_callback,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_si_string_u64(
        x: u64,
        unit: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_samplerate_string(samplerate: u64) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_period_string(v_p: u64, v_q: u64) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_voltage_string(v_p: u64, v_q: u64) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_parse_sizestring(
        sizestring: *const ::std::os::raw::c_char,
        size: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_parse_timestring(timestring: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn sr_parse_boolstring(boolstring: *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn sr_parse_period(
        periodstr: *const ::std::os::raw::c_char,
        p: *mut u64,
        q: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_parse_voltage(
        voltstr: *const ::std::os::raw::c_char,
        p: *mut u64,
        q: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_sprintf_ascii(
        buf: *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_vsprintf_ascii(
        buf: *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_snprintf_ascii(
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_vsnprintf_ascii(
        buf: *mut ::std::os::raw::c_char,
        buf_size: size_t,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_parse_rational(
        str: *const ::std::os::raw::c_char,
        ret: *mut sr_rational,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_package_version_major_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_package_version_minor_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_package_version_micro_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_package_version_string_get() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_lib_version_current_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_lib_version_revision_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_lib_version_age_get() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sr_lib_version_string_get() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_strerror(error_code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sr_strerror_name(error_code: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
